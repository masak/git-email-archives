X-From-Line: git-owner@vger.kernel.org  Tue Apr 19 16:41:43 2005
Return-Path: <git-owner@vger.kernel.org>
X-Original-To: tkil@scrye.com
Delivered-To: tkil@scrye.com
Received: from vger.kernel.org (vger.kernel.org [12.107.209.244])
	by mail.scrye.com (Postfix) with ESMTP id A68301E7B1E
	for <tkil@scrye.com>; Tue, 19 Apr 2005 16:41:43 -0600 (MDT)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S261709AbVDSWl3 (ORCPT <rfc822;tkil@scrye.com>);
	Tue, 19 Apr 2005 18:41:29 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S261712AbVDSWl2
	(ORCPT <rfc822;git-outgoing>); Tue, 19 Apr 2005 18:41:28 -0400
Received: from sb0-cf9a48a7.dsl.impulse.net ([207.154.72.167]:487 "EHLO
	madrabbit.org") by vger.kernel.org with ESMTP id S261709AbVDSWkr
	(ORCPT <rfc822;git@vger.kernel.org>);
	Tue, 19 Apr 2005 18:40:47 -0400
Received: from orca.madrabbit.org (orca.madrabbit.org [192.168.1.51])
	by madrabbit.org (Postfix) with ESMTP
	id 9696E4C0AE4; Tue, 19 Apr 2005 15:40:43 -0700 (PDT)
Subject: Re: [darcs-devel] Darcs and git: plan of action
From: Ray Lee <ray-lk@madrabbit.org>
To: Kevin Smith <yarcs@qualitycode.com>
Cc: git@vger.kernel.org, darcs-devel@darcs.net
In-Reply-To: <4264677A.9090003@qualitycode.com>
References: <20050418210436.23935.qmail@science.horizon.com>
	 <1113869248.23938.94.camel@orca.madrabbit.org>
	 <42645969.2090609@qualitycode.com>
	 <1113874931.23938.111.camel@orca.madrabbit.org>
	 <4264677A.9090003@qualitycode.com>
Content-Type: text/plain
Organization: http://madrabbit.org/
Date:	Tue, 19 Apr 2005 15:40:42 -0700
X-Gnus-Mail-Source: directory:~/.incoming-mail
Message-Id: <1113950442.29444.31.camel@orca.madrabbit.org>
Mime-Version: 1.0
X-Mailer: Evolution 2.2.1.1 
Content-Transfer-Encoding: 7bit
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List:	git@vger.kernel.org
X-Spam-Checker-Version: SpamAssassin 3.0.2 (2004-11-16) on brand.scrye.com
X-Spam-Level: 
X-Spam-Status: No, score=-2.6 required=5.0 tests=BAYES_00 autolearn=ham 
	version=3.0.2
Lines: 127
Xref: brand.scrye.com linux.git:859

(Sorry for the delayed reply -- I'm living on tape delay for a bit.)

On Mon, 2005-04-18 at 22:05 -0400, Kevin Smith wrote:
> >>>>The other is "replace very instace of identifier `foo` with identifier`bar`".
> >>>
> >>>That could be derived, however, by a particularly smart parser [1].
> >>
> >>No, it can't. Seriously. A darcs replace patch is encoded as rules, not
> >>effects, and it is impossible to derive the rules just by looking at the
> >>results. Not difficult. Impossible.
> >  
> > If I do a token replace in an editor (say one of those fancy new-fangled
> > refactoring thangs, or good ol' vi), a token-level comparator can
> > discover what I did. That link I sent is an example of one such beast.
> 
> The big feature of a darcs replace patch is that it works forward and
> backward in time.

That's *not* a feature of the token replace patch, however. That's a
feature of the darcs commutation machinery, correct? (With the obvious
caveat that darcs can only *do* the commutation if it has correctly
nuanced darcs-style token replace patches, rather than mere ASCII
textual diffs.)

> Let me try to come up with an example that can help
> explain it. Hopefully I'll get it right. Let's start with a file like
> this that exists in a project for which both you and I have darcs repos:
> 
> cat
> dog
> fish
> 
> Now, you change it to:
> 
> cat dog
> dog
> fish
> 
> while I simultaneously do a replace of "dog" with "plant", resulting in:
> 
> cat
> plant
> fish
> 
> We merge. The final result in both of our trees is:
> 
> cat plant
> plant
> fish

Okay, that all makes sense.

> Notice that just by looking at my diffs, you can't tell that I used a
> replace operation.

Here's where we disagree. If you checkpoint your tree before the
replace, and immediately after, the only differences in the
source-controlled files would be due to the replace. And since the
language of the file is known (and thereby the tokenization -- it *is*
well-defined), then a tokenizer that compares the before and after trees
(for just the files that changed, obviously), can discover what you did,
and promote the mere ASCII diff into a token-replace diff. (The same
sort of idea could be done for reindention, I'd hope.)

> I didn't just replace the instances of "dog" that
> were in my file at that moment. I conceptually replaced all instances,
> including ones that aren't there yet.

Well yes, that's exactly what we want. And the key point of all of this
is that there's no magic here. The darcs machinery does all the
commutations such that the patches can wiggle together without
conflicts. To do it's job, of course, it needs nuanced patches, rather
than the quite literal ones generated by diff.

We agree on everything except that it's provable that one can discover a
replace operation, given a before and after tree.

> Now, I should mention here that I personally dislike the replace
> operation, and I think it is more dangerous than helpful. However, other
> darcs users are quite happy with it, and it certainly is a creative and
> powerful feature.

It's creative alright, though I had the same misgivings. In my common
code workflow, I almost never have global tokens -- all my replaces
would be per function, so I never saw an opportunity to use it when I
was screwing around with darcs.

> Other creative patch types have also been dreamed of. For example, a
> powerful language-specific refactoring operation has been discussed as a
> far-future possibility. That would be safe, and cool.

<subliminal> indention patch type, indention patch type... </subliminal>

> > > Automated refactoring tools, for example, perform the
> > > rename+modify as an atomic operation.
> > [...]
> Although there are no such nifty refactoring tools available today, they
> will exist at some point.

Yeah, I spent some time drooling over the refactoring editors before
slapping myself and deciding I'd wait for others to live on that
bleeding edge for a while. I've had to clean up too much code from other
people.

> Even without tools, many shops have policies against checking in code
> that won't compile. If you rename a java class, you must simultaneously
> perform the rename and modify the class name inside. If you commit
> between those steps, it's broken.

I'm trying hard to find a nice way to say that's silly. I'm failing. My
suggestion in that case would be that the local coder commit many
patches to a local repository, one of which is the rename. Then upon
completion of the refactoring, the set of patches is committed to the
group repository. Tags before and after preserve the repository's
precondition that it always compiles.

> [I do realize that the kernel doesn't have java code, by the way.]

Don't worry, I didn't think that you did :-).

Ray

-
To unsubscribe from this list: send the line "unsubscribe git" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

